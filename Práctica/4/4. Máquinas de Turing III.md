<h1 align="center">Práctica 4</h1>

## 1. Construir una máquina de Turing que escriba en la primera cinta las palabras de $\lbrace 0,1 \rbrace^*$ en orden canónico separadas por un símbolo ";". Obviamente esta máquina nunca se detiene.

$\dots$

## 2. Sean $\Sigma = \lbrace a,b \rbrace$ y $\mathscr{L}$ el conjunto de todos los lenguajes definidos sobre $\Sigma$. Diga si las siguientes afirmaciones son verdaderas o falsas:

### a. $\mathscr{L} - R = \emptyset$

**Falso**, porque $\mathscr{L}$ incluye a todos los lenguajes posibles sobre el alfabeto $\Sigma$. Si excluimos de este conjunto a todos los lenguajes decidibles, aún quedan los lenguajes recursivamente enumerables que no son decidibles. Contraejemplo: $\overline{L_d} \notin \mathscr{L}, \overline{L_d} \notin R$

### b. $RE - R \neq \emptyset$

**Verdadero**, porque existen lenguajes que son recursivamente enumerables pero no decidibles, como por ejemplo $L_u$. $L_u \in (RE - R)$

### c. $\lbrace \lambda \rbrace \in (\mathscr{L} - \text{CO-RE})$

**Verdadero**, porque $\lbrace \lambda \rbrace \in RE$ y $RE \subset (\mathscr{L} - \text{CO-RE})$ TODO: Mal resuelto, es falso.

### d. $RE \cup R = \mathscr{L}$

**Falso**, contraejemplo: $\overline{L_u} \in \mathscr{L}$ pero $\overline{L_u} \notin (RE \cup R)$

### e. $\Sigma^* \in R$

**Verdadero**. Existe MT $M$ que acepta todas las cadenas posibles del lenguaje y siempre se detiene. $\delta(q_0, x) = (q_A, x, S)$, $\forall x \in \Sigma$.

### f. $\emptyset \in RE$

**Verdadero**. Existe MT $M$ que rechaza todas las cadenas posibles del lenguaje, es decir, $L(M) = \emptyset$.

### g. $\text{CO-RE} = RE$

**Falso**, contraejemplo: $(\text{CO-RE} - RE) \neq \emptyset$ porque por ejemplo $L_D \in (\text{CO-RE} - RE)$

### h. $(\mathscr{L} - RE) = \text{CO-RE}$

**Falso**, contraejemplo: $L \in (\mathscr{L} - RE)$ pero $L \notin \text{CO-RE}$, con $L$ el lenguaje visto en la teoría.

### i. $ab \in \Sigma^*$

**Verdadero**. La cadena "ab" está formada por símbolos del alfabeto $\Sigma = \lbrace a,b \rbrace$, por lo tanto $ab \in \Sigma^*$

### j. $\text{CO-R} \subset \text{CO-RE}$

**Verdadero**. Por teorema se sabe que $R \subseteq \text{CO-RE}$, y como $\text{CO-R} = R$, se puede reemplazar $\text{CO-R} \subset \text{CO-RE}$.

### k. $a \in R$

**Falso**. El conjunto $R$ está formado por lenguajes (que son conjuntos), no por símbolos individuales. Por lo tanto, $a$ no puede pertenecer a $R$.

### l. $\lbrace a \rbrace \in RE$

**Verdadero**. Existe una máquina de Turing que acepta la cadena "a" y rechaza todas las demás cadenas, por lo tanto, el lenguaje $\lbrace a \rbrace$ es recursivamente enumerable. Es decir, $L(M) = \lbrace a \rbrace$

## 3. Si $L \in (RE - R)$

### a. ¿Existirá alguna máquina de Turing que rechace parando en $q_R$ si su entrada está en $L$ y rechace loopeando si su entrada no está en $L$?

Sí, existe una MT que cumple con las condiciones:

1. Para cada cadena válida $w \in L$, la máquina va al estado de rechazo $q_R$ y se detiene.
2. Para cada cadena inválida $z \notin L$, la máquina va a un estado de loopeo $q_R$ y nunca se detiene.

Se puede construir con las siguientes deltas:

$\delta(q_0, w) = (q_R, w, S) \quad \forall w \in L$
$\delta(q_0, z) = (q_L, z, S) \quad \forall z \notin L$
$\delta(q_L, z) = (q_L, z, S)$

### b. ¿Existirá alguna máquina de Turing que rechace loopeando si su entrada está en $L$ y rechace parando en $q_R$ si su entrada no está en $L$?

No, porque como se sabe que $L$ no es decidible, no existe una MT que siempre rechace todas las cadenas que no pertenecen a $L$ deteniéndose en el estado de rechazo $q_R$.

Si la máquina se detuviera para todas las cadenas que no están en $L$, entonces estaría decidiendo el lenguaje, lo cual contradice la premisa de que $L \in (RE - R)$.

### c. De existir, que lenguaje reconocería esta máquina de Turing?

Para el inciso a), la máquina reconoce el lenguaje vacío, $L = \emptyset$.

## 4. Sea $L = \lbrace w \mid \text{Existe alguna Máquina de Turing M que acepta w} \rbrace$ ¿$L \in R$? Justifique.

$L$ es otra forma de escribir al lenguaje $\Sigma^*$, porque todas las cadenas posibles $w$ pueden ser aceptadas por alguna máquina de Turing $M$. Por lo tanto, $L = \Sigma^*$.

$\Sigma^* \in R$ se cumple porque existe una máquina de Turing M que acepta todas las cadenas posibles del lenguaje y siempre se detiene. Por ejemplo, la máquina con la siguiente delta:

$\delta(q_0, B) = (q_A, B, S)$
$\delta(q_0, x) = (q_A, x, S) \quad \forall x \in \Sigma$

## 5. Conteste y justifique:

### a. ¿$\mathscr{L}$ es un conjunto infinito contable?

$\mathscr{L} = \mathcal{P}(\Sigma^*)$.

Como $\Sigma^*$ es un conjunto infinito contable, su conjunto potencia $\mathcal{P}(\Sigma^*)$ es un conjunto infinito **incontable** (por teorema de Cantor). Por lo tanto, $\mathscr{L}$ no es un conjunto infinito contable, si no **incontable**.

### b. ¿$RE$ es un conjunto infinito contable?

$RE$ es un conjunto infinito contable, ya que para todo lenguaje recursivamente enumerable $L$, existe al menos una máquina de Turing $M$ que lo reconoce. Y como el conjunto de todas las máquinas de Turing es infinito contable, entonces el conjunto de lenguajes recursivamente enumerables $RE$ también es infinito contable.

### c. ¿$\mathscr{L} – RE$ es un conjunto infinito contable?

$\mathscr{L}$ es un conjunto infinito **incontable** y $RE$ es un conjunto infinito **contable**. Como la diferencia entre un conjunto infinito incontable y un conjunto infinito contable es siempre un conjunto infinito incontable, entonces $\mathscr{L} – RE$ es un conjunto infinito **incontable**.

### d. Existe algún lenguaje $L \in \mathscr{L}$ tal que $L$ sea infinito no contable?

Todo lenguaje $L \in \mathscr{L}$ es un subconjunto de $\Sigma^*$. Como se sabe que $\Sigma^*$ es un conjunto infinito contable, entonces todos sus subconjuntos también son conjuntos infinitos contables (o finitos). Por lo tanto, no existe ningún lenguaje $L \in \mathscr{L}$ que sea infinito no contable.

## 6. Sea $L$ un lenguaje definido sobre $\Sigma$. Demostrar que:

### a. $\overline{L} \notin R \Rightarrow L \notin R$

$\dots$

### b. $(L_1 \in RE) \land (L_2 \in RE) \Rightarrow L_1 \cap L_2 \in RE$

$\dots$

### c. $(L_1 \in RE) \land (L_2 \in RE) \Rightarrow L_1 \cup L_2 \in RE$

$\dots$

### d. La unión de un número finito de lenguajes recursivamente enumerables es un lenguaje recursivamente enumerable.

$\dots$

## 7. Para los casos a, b y c del punto anterior ¿valen las recíprocas? Justifique.

$\dots$

## 8. Si $L$ es un subconjunto de un lenguaje recursivamente enumerable, ¿Puede afirmarse entonces que $L$ es recursivamente enumerable? Justifique.

Sea $L_1 \in RE$ un lenguaje recursivamente enumerable y sea $L_2 \subseteq L_1$ un subconjunto de $L_1$.

No es posible afirmar que $L_2$ es recursivamente enumerable, ya que existen subconjuntos de lenguajes recursivamente enumerables que no son recursivamente enumerables. Contraejemplo: $L_D \subseteq \Sigma^*, \Sigma^* \in RE, L_D \notin RE$.

## 9. Dado $L_1$, un lenguaje recursivo cualquiera

### $L_2 = \lbrace \langle M\rangle \mid L(M) = \overline{L_1} \rbrace$

### $L_3 = \lbrace \langle M\rangle \mid L(M) = \overline{L_1} \text{ y } M \text{ siempre se detiene} \rbrace$

### Determine si $(L_2 – L_3) = \emptyset$. Justifique su respuesta.

$\dots$

## 10. Sean los lenguajes $L = \lbrace \langle M\rangle \mid M \text{ siempre se detiene} \rbrace$ y $L_R = \lbrace \langle M\rangle \mid L(M) \in R  \rbrace$. ¿Cuál es la afirmación correcta?

### a. $L \subset L_R$

$\dots$

### b. $L_R \subset L$

$\dots$

### c. $L = L_R$

$\dots$

## 11. Encuentre una justificación para cada una de las siguientes afirmaciones:

### a. $\emptyset \in RE$

1. Como $\emptyset \subseteq \Sigma^*$, $\emptyset$ es un lenguaje.
2. $\emptyset \in R$ porque existe una máquina de Turing que rechaza todas las cadenas posibles del lenguaje y además siempre termina, es decir, $L(M) = \emptyset$:
   1. $\delta(q_0, B) = (q_R, B, S)$
   2. $\delta(q_0, x) = (q_R, x, S) \quad \forall x \in \Sigma$
3. Como $R \subseteq RE$, entonces $\emptyset \in RE$.

### b. Si $L$ es un lenguaje formado por una sola palabra, entonces $L \in R$

1. $L = \lbrace w \rbrace$, con $w \in \Sigma^*$.
2. $L \in R$ si existe una máquina de Turing que acepta la palabra $w$, rechaza todas las demás palabras, y además siempre se detiene.
3. Toda palabra $w$ es una secuencia finita de símbolos de $\Sigma$.
4. Por lo tanto se puede construir una MT $M$ que pase por una cantidad finita de estados para aceptar la palabra $w$, procesando sus símbolos uno por uno, y luego se detenga en el estado de aceptación $q_A$. Para todas las demás palabras, la máquina se detiene en el estado de rechazo $q_R$. Por lo tanto no loopea y $L \in R$.

### c. Si $L$ es un lenguaje finito, entonces $L \in R$

1. Sea $L = \lbrace w_1, w_2, \ldots, w_n \rbrace$ con $w_i \in \Sigma^*$.
2. $L \in R$ si existe una máquina de Turing que acepta cada palabra $w_i$, rechaza todas las demás palabras, y además siempre se detiene.
3. Como $L$ es finito, existe una cantidad finita de palabras $w_i$.
4. Por lo tanto se puede construir una MT $M$ que pase por una cantidad finita de estados para aceptar cada palabra $w_i$, procesando sus símbolos uno por uno, y luego se detenga en el estado de aceptación $q_A$. Para todas las demás palabras, la máquina se detiene en el estado de rechazo $q_R$. Por lo tanto no loopea y $L \in R$.

## 12. Demuestre que si el $\text{Halting Problem (HP)}$ es un lenguaje recursivo entonces podría construirse una máquina de Turing que acepte el lenguaje universal $L_u$, y que se detenga para todo $w \in \Sigma^*$ ¿Qué puede decir entonces sobre la recursividad de $HP$?

### $HP = \lbrace (\langle M \rangle, w) \mid \text{M se detiene con input w} \rbrace$

### $L_u = \lbrace (\langle M \rangle, w) \mid \text{M acepta w} \rbrace$

Tenemos una proposición del estilo $(HP \in R \rightarrow L_u \in R)$. Para probar que esto es falso, se puede asumir que $HP \in R$ es verdadero y luego llegar a que $L_u \in R$ es falso.

Por premisa, se asume que $HP$ es un lenguaje decidible $(HP \in R)$. Por lo tanto, existe una máquina de Turing $M_{HP}$ que decide $HP$, es decir, que hace lo siguiente:

- **Recibe** un input $(\langle M \rangle, w)$, es decir, un código binario de una MT $M$ y una cadena $w$ que es la entrada de $M$.
- **Acepta** si $M$ se detiene con input $w$.
- **Rechaza** si $M$ no se detiene (loopea) con input $w$.
- Como $M_{HP}$ es decidible, **siempre se detiene (nunca loopea)**.

Luego se puede construir una máquina de Turing $M_{L_u}$ que decide $L_u$ utilizando a $M_{HP}$ de la siguiente manera:

- Recibe un input $(\langle M \rangle, w)$.
- Ejecuta a $M_{HP}$ con el input $(\langle M \rangle, w)$.
  - Como $M_{HP}$ siempre se detiene, $M_{L_u}$ espera a que $M_{HP}$ termine.
- Si $M_{HP}$ **rechaza**:
  - Esto equivale a que $M$ no se detiene con input $w$.
  - Como $M$ no se detiene, entonces $M$ no puede aceptar $w$.
  - Por lo tanto $(\langle M \rangle, w) \notin L_u$.
  - $M_{L_u}$ rechaza, y luego se detiene.
- Si $M_{HP}$ **acepta**:
  - Esto equivale a que $M$ se detiene con input $w$.
  - Como sabemos que $M$ se detiene con input $w$, entonces podemos simular su ejecución de forma segura sin riesgo de loopear.
  - $M_{L_u}$ simula a $M$ con el input $w$:
  - Si $M$ acepta $w$, entonces $M_{L_u}$ acepta.
  - Si $M$ rechaza $w$, entonces $M_{L_u}$ rechaza.

Como $M_{HP}$ siempre se detiene, y la simulación de $M$ con input $w$ también se detiene (porque en este caso $M$ se detiene), entonces $M_{L_u}$ siempre se detiene.

Por lo tanto, se ha construido una máquina de Turing $M_{L_u}$ que decide $L_u$, lo que implica que $L_u \in R$.

Sin embargo, se **sabe por teorema que $L_u$ no es un lenguaje decidible $(L_u \notin R)$**. Esto lleva a una contradicción, lo que implica que la suposición inicial $(HP \in R)$ es falsa.

Se puede decir entonces que el Halting Problem $HP$ **no es un lenguaje recursivo $(HP \notin R)$**.

## 13. Demuestre que $L_{NV} \in RE$

### $L_{NV} = \lbrace \langle M \rangle \mid L(M) \neq \emptyset \rbrace$

$L_{NV} \in RE$ si existe una máquina de Turing $M$ tal que $L(M) = L_{NV}$. Es decir, si existe una MT $M$ que acepte todas las cadenas que son códigos binarios de máquinas de Turing que reconocen al menos una cadena, y rechaze todas las demás cadenas ya sea loopeando o yendo al estado de rechazo $q_R$.

Esta MT existe y se puede construir de la siguiente manera:

- Recibe un input $\langle M' \rangle$, que es el código binario de una máquina de Turing $M'$.
- Si $\langle M' \rangle$ no es un código válido de una máquina de Turing:
  - Entonces $M'$ no reconoce ninguna cadena, es decir, $L(M') = \emptyset$.
  - $M$ rechaza el input $\langle M' \rangle$ y se detiene.
- Si $\langle M' \rangle$ es un código válido de una máquina de Turing:
  - $M$ simula la ejecución de $M'$ con todas las posibles cadenas de entrada $w \in \Sigma^*$, una por una.
  - Si durante la simulación, $M'$ acepta alguna cadena $w$:
    - Entonces $L(M') \neq \emptyset$.
    - $M$ acepta el input $\langle M' \rangle$ y se detiene.
  - Si durante la simulación, $M'$ no acepta ninguna cadena $w$:
    - Entonces $L(M') = \emptyset$.
    - $M$ rechaza el input $\langle M' \rangle$ y se detiene.
    - O bien, $M$ puede loopear en este caso, si $M'$ también loopea.

Por lo tanto, se ha construido una máquina de Turing $M$ que acepta todas las cadenas que son códigos binarios de máquinas de Turing que reconocen al menos una cadena, y rechaza todas las demás cadenas. Esto implica que $L_{NV} \in RE$.
